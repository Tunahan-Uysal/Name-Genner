import 'dart:convert';
import 'dart:io';
import 'package:path_provider/path_provider.dart';
import 'package:logger/logger.dart';

/// Class for managing the JSON file of saved names, with default behaviors.
class SavedNamesJsonController {
  static const String _defaultFileName = 'favorited_names.json';
  late final File _file; // Now final after initialization
  final _log = Logger();
  late final Future<void> _initialization;

  // Static instance for singleton behavior
  static final SavedNamesJsonController _instance =
  SavedNamesJsonController._internal();

  // Factory constructor for singleton access
  factory SavedNamesJsonController() {
    return _instance;
  }

  // Internal constructor for initialization
  SavedNamesJsonController._internal() {
    _initialization = _initializeFile();
  }

  // Initialization is now synchronous
  Future<void> _initializeFile() async {
    final directory = await getApplicationDocumentsDirectory();
    _file = File('${directory.path}/$_defaultFileName');
    if (!await _file.exists()) {
      await _file.create();
      await _file.writeAsString('[]');
    }
  }

  /// Returns a list of strings from the JSON file.
  ///
  /// Used in the app for displaying the saved names in the favourites page.
  Future<List<String>> readJsonAsStrings() async {
    await _initialization;
    try {
      if (!await _file.exists()) {
        await _file.create();
        await _file.writeAsString('[]'); // Initialize with an empty array
      }

      String contents = await _file.readAsString();
      List<dynamic> jsonData = jsonDecode(contents);
      return jsonData.map((item) => item.toString()).toList();
    } catch (e) {
      _log.e('Error reading or decoding JSON: $e');
      return [];
    }
  }

  /// Adds a string to the JSON file.
  ///
  /// Saves new names generated by the app.
  Future<void> includeStringInJson(String newString) async {
    await _initialization;
    try {
      //We no longer need to await the initialization, since it happens on start
      String contents = await _file.readAsString();
      List<dynamic> jsonData = jsonDecode(contents);

      if (jsonData.contains(newString)) {
        _log.i('String already exists in JSON.');
        return;
      }

      jsonData.add(newString);
      await _file.writeAsString(jsonEncode(jsonData));
      _log.i('String added to JSON.');
    } catch (e) {
      _log.e('Error reading, decoding, or writing JSON: $e');
      await _createNewJsonFile();
      await includeStringInJson(newString);
    }
  }

  /// Creates new JSON File for saving Names if not found
  Future<void> _createNewJsonFile() async {
    _log.i('Creating new JSON file.');
    await _file.writeAsString('[]');
  }

  /// Deletes a string from the JSON file.
  ///
  /// Used in the app for deleting the names from the favourites page.
  /// Works by finding the string provided by nameToDelete and removing where it is found.
  Future<void> deleteDataByName(String nameToDelete) async {
    await _initialization;
    try {
      //We no longer need to await the initialization, since it happens on start
      String contents = await _file.readAsString();
      List<dynamic> jsonData = jsonDecode(contents);

      jsonData.removeWhere((item) => item.toString() == nameToDelete);

      await _file.writeAsString(jsonEncode(jsonData));
      _log.i('Data deleted by name.');
    } catch (e) {
      _log.e('Error reading, decoding, or writing JSON: $e');
    }
  }

  /// Deletes a string from the JSON file.
  ///
  /// Used in the app for deleting the names from the favourites page.
  /// Works by finding the index provided by indexToDelete (based on row) and removing where it is found.
  Future<void> deleteDataByIndex(int indexToDelete) async {
    await _initialization;
    try {
      //We no longer need to await the initialization, since it happens on start
      String contents = await _file.readAsString();
      List<dynamic> jsonData = jsonDecode(contents);

      if (indexToDelete >= 0 && indexToDelete < jsonData.length) {
        jsonData.removeAt(indexToDelete);
        await _file.writeAsString(jsonEncode(jsonData));
        _log.i('Data deleted by index.');
      } else {
        _log.w('Invalid index for deletion.');
      }
    } catch (e) {
      _log.e('Error reading, decoding, or writing JSON: $e');
    }
  }

  /// Deletes the entire JSON file.
  ///
  /// Used only in Settings Page to clear the saved names.
  /// Should be used with caution. Does not back up the data.
  Future<void> deleteEntireJson() async {
    await _initialization;
    try {
      //We no longer need to await the initialization, since it happens on start
      await _file.delete();
      _log.i('Entire JSON data deleted (file removed).');
    } catch (e) {
      _log.e('Error deleting JSON file: $e');
    }
  }
}